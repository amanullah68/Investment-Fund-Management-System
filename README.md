# Investment Fund Management System

## Description
This document outlines the system architecture for an Investment Fund Management System that utilizes blockchain technology to manage investments and redemptions. The system interfaces with a smart contract, handles transactions, tracks fund metrics for caching, monitors Investment, Redemption, and MetricsUpdated events, stores data in a database, and ensures data consistency between the blockchain and the backend database. This solution aims to provide a robust and transparent platform for investment fund management.

## System Design Document
For a detailed overview of the system architecture including architecture diagrams, data models, and component interactions, you can refer to the System Design Document in two formats:
- View the [System Design Document on Google Docs](https://docs.google.com/document/d/1KUEO-AA1abU-fz0toze_YHEmIE1XlMwG_fz7Alyo3W8/edit?usp=sharing).
- Download the local PDF file directly from the project repository: [System Design Document.pdf](./System Design Document.pdf).


## Prerequisites
To run this project, you will need:
- Node.js (v22.14.0)
- PostgreSQL (v13)
- Redis (v7.2.7)

## Setup Instructions

### Installation
Follow these steps to get your development environment set up:
1. Clone the repository:
   ```
   git clone https://github.com/amanullah68/Investment-Fund-Management-System/tree/libre-capital/assessment
   ```
2. Install dependencies:
   ```
   npm install
   # or
   yarn install
   ```
3. Set up your PostgreSQL database:
   - Create a database and user as specified in your `.env` file
4. Set up Redis:
   - Ensure Redis is installed and running on your system
5. Configure your environment variables:
   - Copy the `.env.example` file to a new file named `.env`:
     ```
     cp .env.example .env
     ```
   - Edit the `.env` file with the appropriate settings

### Running the Application
To run the application in development, use:
   ```
   npm run dev
   # or
   yarn run dev
   ```
For production, you can start the application using:
   ```
   npm start
   # or
   yarn start
   ```
Additionally, to build the application for production, use:
   ```
   npm run build
   # or
   yarn run build
   ```

Run with Docker
   ```
   docker-compose up --build
   ```

### Logging
The system logs various operational data which can be helpful for monitoring and troubleshooting. All logs are stored in the `logs` folder within the project directory.

## Testing
To run tests, execute the following command:
   ```
   npm test
   # or
   yarn test
   ```
This command will run the test suite configured for your project, ensuring all components behave as expected.

## Implementation

### Error Handling and Service Reconnection
This backend service is designed to handle errors robustly and maintain high availability:
- **Service Reconnection**: In case of a disconnection, the service will attempt to automatically reconnect to PostgreSQL, Redis, or the RPC interface.
- **Health Checks**: Utilize the `{{base_url}}/health` endpoint to check the operational status of connected services. This endpoint will identify which services are currently down, aiding in quick diagnostics and recovery.

## Postman Collection
A Postman collection named `Fund_Investment.postman_collection.json` is included in the project to facilitate easier testing and interaction with the API endpoints. This collection provides pre-configured requests for all available endpoints, allowing for quick and effective testing.

## Project Structure

The Investment Fund Management System is organized into several key directories, each serving a specific function:

- **/logs**: Stores log files generated by the application.

- **/src**: Contains all the source code for the project.
- **/config**: Configuration files for the application.
- **/database**: Database access and management layers.
- **/entities**: Definitions of data entities.
- **/errors**: Custom error handlers and definitions.
- **/infra**: Infrastructure setup files.
- **/middleware**: Express middleware modules.
- **/modules/fund**: Contains all fund management related files:
 - `fund.controller.ts`: Handles incoming requests and prepares responses.
 - `fund.routes.ts`: Defines routes for fund management operations.
 - `fund.service.ts`: Business logic for fund operations.
 - `fund.validators.ts`: Validation logic for request data.
- **/services**: Services used across the application.
- **/types**: TypeScript type definitions and interfaces.
- **/utils**: Utility functions and helpers.
- `app.ts`: Main application setup and entry point.

- **/tests**: Test scripts and files for unit and integration testing.

This structure is designed to promote separation of concerns and maintainability of the codebase. For more detailed information on each component, refer to the source files within each directory.

## API Documentation
This section describes the available endpoints in the API:

### GET /health
- **Description**: Checks the health of the services like RPC, PostgreSQL, and Redis.
- **Success Response**:
  - **Code**: 200
  - **Content**: 
    ```json
    {
        "success": true,
        "message": "Service health status",
        "data": {
            "status": "OK",
            "services": {
                "postgres": true,
                "redis": true,
                "rpc": true
            },
            "timestamp": 1741031269828,
            "uptime": 18.015506256
        }
    }
    ```

### GET /fund/balance/:address
- **Description**: Fetches the balance of a user from the smart contract.
- **URL Parameters**:
  - `address`: Ethereum address of the user.
- **Success Response**:
  - **Code**: 200
  - **Content**:
    ```json
    {
        "success": true,
        "message": "Balance retrieved",
        "data": {
            "address": "0x11b08dF706A425D7A1b280D953e1576557402149",
            "balance": "268000000"
        }
    }
    ```

### GET /fund/fundMetrics
- **Description**: Fetches Fund Metrics data from the smart contract and caches it in Redis for 1 minute.
- **Success Response**:
  - **Code**: 200
  - **Content**:
    ```json
    {
        "success": true,
        "message": "Metrics retrieved",
        "data": {
            "totalAssetValue": "268000000",
            "sharesSupply": "268000000",
            "lastUpdateTime": "1741031652",
            "cacheStatus": "fresh"
        }
    }
    ```

### POST /fund/invest
- **Description**: Executes the `invest` function of the smart contract to process an investment.
- **Body**:
  ```json
  {
      "investor": "0x11b08dF706A425D7A1b280D953e1576557402149",
      "usdAmount": 10
  }
  ```
- **Success Response**:
  - **Code**: 200
  - **Content**:
    ```json
    {
        "success": true,
        "message": "Investment processed",
        "data": {
            "status": "success",
            "txHash": "0x99527eb74bd51c3000dd0a2cf236811d438d2d17687e7b113360cdce7c1eadcd"
        }
    }
    ```

### POST /fund/redeem
- **Description**: Executes the `redeem` function of the smart contract to process a redemption.
- **Body**:
  ```json
  {
      "investor": "0x11b08dF706A425D7A1b280D953e1576557402149",
      "shares": 20000000
  }
  ```
- **Success Response**:
  - **Code**: 200
  - **Content**:
    ```json
    {
        "success": true,
        "message": "Redemption processed",
        "data": {
            "status": "success",
            "txHash": "0x37fb6759d2b703054e7358a30edc9f1985b6293bafd38b1f6bc15804361459cf"
        }
    }
    ```

## Main Design Decisions
The key architectural and design choices made for this project include:

1. **NodeNext with TypeScript**: The project leverages NodeNext combined with TypeScript for server-side logic to make use of strong typing and the latest ECMAScript features, ensuring more reliable and maintainable code.

2. **PostgreSQL**: Selected for its robustness and performance capabilities, PostgreSQL serves as the structured data storage solution to handle complex queries and large volumes of data.

3. **Redis**: Implemented for caching frequently accessed data such as fund metrics. This reduces load on the database and improves response times for end users.

4. **Blockchain Smart Contracts**: Direct interfacing with blockchain smart contracts is employed to manage financial transactions such as investments and redemptions, ensuring integrity and transparency.

5. **Event Tracking**: The system is designed to track and store `Investment`, `Redemption`, and `MetricsUpdated` events from the smart contract into the PostgreSQL database. This enables accurate and timely updates for stakeholders and maintains historical data integrity.

6. **Caching Strategy for Fund Metrics**: For the `fundMetrics` endpoint, data is fetched directly from the smart contract and cached in Redis for up to 1 minute. This approach ensures that users receive up-to-date information while minimizing repetitive queries to the blockchain, optimizing system performance and resource usage.

7. **Robust Error Handling and Service Reconnection**: The system includes comprehensive error handling to manage and respond to various error states gracefully. Additionally, should any of the essential services like PostgreSQL, Redis, or the RPC interface disconnect, the system is designed to automatically attempt reconnection, enhancing the resilience and uptime of the service.

## Possible Improvements

1. **Authentication**: Implement authentication mechanisms to secure access to the API endpoints. This will ensure that only authorized users can interact with the system's functionalities.

2. **Asynchronous Transaction Handling**: Instead of waiting for a transaction to be confirmed, store the `txHash` temporarily and track the transaction status asynchronously in the backend. This can improve the user experience by reducing wait times.

3. **Gas Parameter Customization**: Allow users to specify the gas price for transactions to manage priority and cost. Additionally, implement functionality to automatically increase the gas price and resend transactions that fail due to low gas prices.

4. **Enhanced Testing**: Expand the test suite to cover more scenarios and edge cases. This will help ensure the robustness and reliability of the system under various conditions.

5. **Dockerization**: Containerize the application using Docker to simplify deployment and ensure consistent environments across development, testing, and production. This would facilitate easier scalability and management of application components.

6. **Use of The Graph for Event Tracking**: Integrate The Graph to index and query blockchain data efficiently. Utilizing The Graph Node could provide more robust and faster data retrieval through GraphQL queries. This would enhance the system's ability to handle event data from smart contracts, potentially improving responsiveness and scalability.


